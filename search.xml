<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>岛屿个数</title>
      <link href="/2024/07/29/%E9%A2%98%E8%A7%A3/"/>
      <url>/2024/07/29/%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="第十四届蓝桥杯省B-岛屿个数"><a href="#第十四届蓝桥杯省B-岛屿个数" class="headerlink" title="[第十四届蓝桥杯省B 岛屿个数]"></a>[第十四届蓝桥杯省B 岛屿个数]</h1><p>小蓝得到了一副大小为 $M×N$ 的格子地图，可以将其视作一个只包含字符 $0$（代表海水）和 $1$（代表陆地）的二维数组，地图之外可以视作全部是海水，每个岛屿由在上/下/左/右四个方向上相邻的 $1$  相连接而形成。</p><p>在岛屿 A 所占据的格子中，如果可以从中选出 k 个不同的格子，使得他们的坐标能够组成一个这样的排列：$(x<em>0,y_0),(x_1,y_1),…,(x</em>{k−1},y_{k−1})$，其中 (x<sub>i+1%k</sub> ,y<sub>i+1 % k</sub>) 是由<br>$(x_i,y_i)$ 通过上/下/左/右移动一次得来的 (0≤i≤k−1)，此时这 k 个格子就构成了一个 “环”。</p><p>如果另一个岛屿 B 所占据的格子全部位于这个 “环” 内部，此时我们将岛屿 B 视作是岛屿 A 的子岛屿。</p><p>若 B 是 A 的子岛屿，C 又是 B 的子岛屿，那 C 也是 A 的子岛屿。</p><p>请问这个地图上共有多少个岛屿？</p><p>在进行统计时不需要统计子岛屿的数目。</p><p><strong>输入格式</strong><br>第一行一个整数 T，表示有 T 组测试数据。</p><p>接下来输入 T 组数据。</p><p>对于每组数据，第一行包含两个用空格分隔的整数 M、N 表示地图大小；接下来输入 M 行，每行包含 N 个字符，字符只可能是 0 或 1。</p><p><strong>输出格式</strong><br>对于每组数据，输出一行，包含一个整数表示答案。</p><p><strong>数据范围</strong><br>对于 30% 的评测用例，1≤M,N≤10。<br>对于 100% 的评测用例，1≤T≤10，1≤M,N≤50。</p><p><strong>输入样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">01111</span></span><br><span class="line"><span class="number">11001</span></span><br><span class="line"><span class="number">10101</span></span><br><span class="line"><span class="number">10001</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">111111</span></span><br><span class="line"><span class="number">100001</span></span><br><span class="line"><span class="number">010101</span></span><br><span class="line"><span class="number">100001</span></span><br><span class="line"><span class="number">111111</span></span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>样例解释</strong><br>对于第一组数据，包含两个岛屿，下面用不同的数字进行了区分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01111</span></span><br><span class="line"><span class="number">11001</span></span><br><span class="line"><span class="number">10201</span></span><br><span class="line"><span class="number">10001</span></span><br><span class="line"><span class="number">11111</span></span><br></pre></td></tr></table></figure><p>岛屿 2 在岛屿 1 的 “环” 内部，所以岛屿 2 是岛屿 1 的子岛屿，答案为 1。</p><p>对于第二组数据，包含三个岛屿，下面用不同的数字进行了区分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">111111</span></span><br><span class="line"><span class="number">100001</span></span><br><span class="line"><span class="number">020301</span></span><br><span class="line"><span class="number">100001</span></span><br><span class="line"><span class="number">111111</span></span><br></pre></td></tr></table></figure><p>注意岛屿 3 并不是岛屿 1 或者岛屿 2 的子岛屿，因为岛屿 1 和岛屿 2 中均没有“环”。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII; </span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> vis1[N][N],vis2[N][N];</span><br><span class="line"><span class="comment">//g陆地，vis1宽搜标记，vis2检查是否成环标记 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    vis1[x][y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nx=x+dx[i],ny=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;a||ny&lt;<span class="number">1</span>||ny&gt;b||vis1[nx][ny]||g[nx][ny]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nx,ny);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> dy[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> nx=x+dx[i],ny=y+dy[i];</span><br><span class="line">        <span class="keyword">if</span>(g[nx][ny]||vis2[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(nx&lt;<span class="number">1</span>||nx&gt;a||ny&lt;<span class="number">1</span>||ny&gt;b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        vis2[nx][ny]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(nx,ny)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(g,<span class="number">0</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">        <span class="built_in">memset</span>(vis1,<span class="number">0</span>,<span class="keyword">sizeof</span> vis1);</span><br><span class="line">        <span class="built_in">memset</span>(vis2,<span class="number">0</span>,<span class="keyword">sizeof</span> vis2);</span><br><span class="line">        </span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line">                <span class="type">char</span> x;cin&gt;&gt;x;</span><br><span class="line">                g[i][j]=x-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(g[i][j]&amp;&amp;vis1[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    vis1[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(i,j);</span><br><span class="line">                    <span class="built_in">memset</span>(vis2,<span class="number">0</span>,<span class="keyword">sizeof</span> vis2);</span><br><span class="line">                    vis2[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">check</span>(i,j)) res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法</title>
      <link href="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/kuaipai.gif" alt="2.gif"></p><p><strong>原理</strong></p><p>选定某个划分值x（一般选取数组首个元素)，将待排数组分为左右两部分。左边均为大于x，右边均为小于x。再递归调用函数处理左右两边。</p><p>快排属于<strong>分治算法</strong>，分治算法都有三步：</p><ol><li>分成子问题</li><li>递归处理子问题</li><li>子问题合并</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归终止</span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x=q[l+r&gt;&gt;<span class="number">1</span>],i=l<span class="number">-1</span>,j=r<span class="number">+1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line"><span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line"><span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line"><span class="built_in">quick_sort</span>(q,j<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>STL</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000000</span><span class="number">+100</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m,i,j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//sort函数即为快排</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习</p><ol><li><a href="https://www.acwing.com/problem/content/787/">快速排序</a></li><li><a href="https://www.acwing.com/problem/content/788/">第k个数</a> </li></ol><hr><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><a href="https://www.bilibili.com/video/BV1Na411e7Vg/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4cf1335c21865cdae9c04c4d1146427a">视频演示</a></p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/guibing.gif" alt="3.gif"></p><p><strong>原理</strong></p><p>将一个无序数组一分为二成两个数组，将两个无序数组变为有序数组后，再使用双指针依次选取最小的数合并为一个数组。</p><p>过程中递归调用分为若干个数组（最小为两个元素一组）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归终止</span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步分为子问题</span></span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//第二步递归处理子问题</span></span><br><span class="line"><span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(q,mid<span class="number">+1</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步合并子问题</span></span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid<span class="number">+1</span>,tmp[r-l<span class="number">+1</span>];</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line"><span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++]=q[i++];</span><br><span class="line"><span class="keyword">else</span> tmp[k++]=q[j++];</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.<a href="https://www.acwing.com/problem/content/789/">归并排序</a></p><p>2.<a href="https://www.acwing.com/problem/content/790/">逆序对的数量</a></p><hr><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><strong>注意边界</strong></p><p>二分法有许多不同的模板，通常是因为<code>int</code>向下取整导致<code>l</code>与<code>r</code>的判定问题。</p><p>这里使用<code>下界-1</code>,<code>上界+1</code>，并且当<code>l+1==r</code>时跳出循环。</p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/erfen.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大化答案伪代码</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//......  计算y的值</span></span><br><span class="line"><span class="keyword">return</span> y&lt;=c;  <span class="comment">//x小，y大</span></span><br><span class="line"><span class="keyword">return</span> y&gt;=c;  <span class="comment">//x小，y大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l=下界<span class="number">-1</span>,r=上界<span class="number">+1</span>;</span><br><span class="line"><span class="keyword">while</span>(l<span class="number">+1</span>&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; <span class="comment">//整数二分</span></span><br><span class="line">        <span class="comment">//int mid=(l+r)/2; 实数二分</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小化答案伪代码</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//......  计算y的值</span></span><br><span class="line"><span class="keyword">return</span> y&gt;=c;  <span class="comment">//x大，y小</span></span><br><span class="line"><span class="keyword">return</span> y&lt;=c;  <span class="comment">//x大，y小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l=下界<span class="number">-1</span>,r=上界<span class="number">+1</span>;</span><br><span class="line"><span class="keyword">while</span>(l<span class="number">+1</span>&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; <span class="comment">//整数二分</span></span><br><span class="line">        <span class="comment">//int mid=(l+r)/2; 实数二分</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.<a href="https://www.acwing.com/problem/content/791/">数的范围</a></p><p>2.<a href="https://www.acwing.com/problem/content/792/">数的三次方根</a></p><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p><strong>例题</strong></p><p>输入一个长度为 $n$ 的整数序列。</p><p>接下来再输入 $m$ 个询问，每个询问输入一对 $l,r$。</p><p>对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。</p><p><strong>朴素算法</strong>：暴力遍历求解,时间复杂度为$O(m*n)$。</p><p><strong>前缀和</strong>：定义一个<code>sum[]</code>数组，<code>sum[i]</code>为前<code>i</code>个数之和，每次只需求<code>sum[r]-sum[l-1]</code>,将时间复杂度由 $O(m*n)$降为$O(m+n)$。</p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/2eadf7531e415ea2b6b4cabd2f19fe6e.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i - <span class="number">1</span>] + a[i];<span class="comment">//前缀和处理操作</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;sum[r] - sum[l - <span class="number">1</span>];<span class="comment">//查询操作</span></span><br></pre></td></tr></table></figure><hr><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p><strong>例题</strong></p><p>输入一个<code>n</code>行<code>m</code>列的整数矩阵，再输入<code>q</code>个询问，每个询问包含四个整数<code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。</p><p><strong>思路</strong></p><p><strong>预处理</strong>同一维前缀和一样，我们先来定义一个二维数组<code>s[][]</code>, <code>s[i][j]</code>表示二维数组中，左上角<code>(1, 1)</code>到右下角<code>(i, j)</code>所包围的矩阵元素的和。接下来推导二维前缀和的公式。</p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/0fc5ed8e9a42ee1d0120690bf1400aab.png" alt="img" style="zoom: 33%;"></p><p><strong>紫色面积</strong>是指<code>(1, 1)</code>左上角到<code>(i, j - 1)</code>右下角的矩形面积, <strong>绿色面积</strong>是指<code>(1, 1)</code>左上角到<code>(i - 1, j )</code>右下角的矩形面积。<strong>每一个颜色的矩形面积都代表了它所包围元素的和。</strong></p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/8b538feb08981caf3a525fc3fda14273.png" alt="在这里插入图片描述"></p><p><strong>预处理公式$O(mn)$</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span> ] + a[i] [j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>查询</strong></p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/858bc708d9f0256e3b41e877a6f7f6ee.png" alt="img" style="zoom:33%;"></p><p><strong>紫色面积</strong>是指 <code>(1, 1)</code>左上角到<code>(x1 - 1, y2)</code>右下角的矩形面积 ，<strong>黄色面积</strong>是指<code>(1, 1)</code>左上角到<code>(x2, y1 - 1)</code>右下角的矩形面积；</p><p><strong>不难推出：</strong></p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/43028b283e44762ecc4c6304416d3497.png" alt="在这里插入图片描述"></p><p><strong>查询公式$O(1)$</strong></p><p><code>(x1, y1)</code>为左上角，<code>(x2, y2)</code>为右下角的子矩阵的和为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[x2, y2] - s[x1 - <span class="number">1</span>, y2] - s[x2, y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><hr><h1 id><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
