<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法笔记（二）—— 数据结构</title>
      <link href="/2024/08/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/08/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>在算法竞赛中，数据量通常会超过$10^6$,使用<code>new</code>函数构造动态链表会超时，因此通常使用数组模拟<strong>静态链表</strong>。</p><p><strong>例题</strong></p><p>实现一个单链表，链表初始为空，支持三种操作：</p><ol><li>向链表头插入一个数；</li><li>删除第 $k$ 个插入的数后面的一个数；</li><li>在第 $k$ 个插入的数后插入一个数。</li></ol><p>现在要对该链表进行 $M$ 次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><img src="/2024/08/18/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/c33b7fc7637b0c763266fd564f95add.jpg" alt="c33b7fc7637b0c763266fd564f95add" style="zoom: 33%;"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head表示头节点下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值是多少</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少(节点i的下一个点的下标是什么)</span></span><br><span class="line"><span class="comment">// idx 存储我们当前已经用到了哪个点(0,1,2...)</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">initialize</span>();</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> x, k;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x); <span class="comment">// k-1, 因为0号点是第一个插入的点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) &#123;</span><br><span class="line">                head = ne[head]; </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/828/">单链表</a></p><hr><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> m,e[N],l[N],r[N],idx=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">l[<span class="number">1</span>]=<span class="number">0</span>,r[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//初始化 第一个点的右边是 1   第二个点的左边是 0</span></span><br><span class="line">idx=<span class="number">2</span>; <span class="comment">//idx 此时已经用掉两个点了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在第 K 个点右边插入一个 X </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx]=x;</span><br><span class="line">l[idx]=k;</span><br><span class="line">r[idx]=r[k];</span><br><span class="line">l[r[k]]=idx;</span><br><span class="line">r[k]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第 k个 点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">r[l[k]]=r[k];</span><br><span class="line">l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line">string op;</span><br><span class="line">cin &gt;&gt; op;</span><br><span class="line"><span class="type">int</span> k, x;</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">&quot;R&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">add</span>(l[<span class="number">1</span>], x); <span class="comment">// 0和 1 只是代表 头和尾  所以  最右边插入 只要在  指向 1的 那个点的右边插入就可以了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;L&quot;</span>)<span class="comment">//同理  最左边插入就是 在指向 0的数的左边插入就可以了   也就是可以直接在 0的 有右边插入</span></span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">0</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;D&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line"><span class="built_in">remove</span>(k + <span class="number">1</span>);<span class="comment">//第 k 个插入元素对应的索引为 k + 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="string">&quot;IL&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line"><span class="built_in">add</span>(l[k + <span class="number">1</span>], x);<span class="comment">// 第 k 个插入元素对应的索引为 k + 1， l[k + 1] 为链表中上一个位置对应的索引</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line"><span class="built_in">add</span>(k + <span class="number">1</span>, x);</span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记（一）—— 基础算法</title>
      <link href="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/kuaipai.gif" alt="2.gif"></p><p><strong>原理</strong></p><p>选定某个划分值x（一般选取数组首个元素)，将待排数组分为左右两部分。左边均为大于x，右边均为小于x。再递归调用函数处理左右两边。</p><p>快排属于<strong>分治算法</strong>，分治算法都有三步：</p><ol><li>分成子问题</li><li>递归处理子问题</li><li>子问题合并</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归终止</span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x=q[l+r&gt;&gt;<span class="number">1</span>],i=l<span class="number">-1</span>,j=r<span class="number">+1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line"><span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line"><span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line"><span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line"><span class="built_in">quick_sort</span>(q,j<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>STL做法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000000</span><span class="number">+100</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,m,i,j;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//sort函数即为快排</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a<span class="number">+1</span>,a<span class="number">+1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习</p><ol><li><a href="https://www.acwing.com/problem/content/787/">快速排序</a></li><li><a href="https://www.acwing.com/problem/content/788/">第k个数</a> </li></ol><hr><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p><a href="https://www.bilibili.com/video/BV1Na411e7Vg/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4cf1335c21865cdae9c04c4d1146427a">视频演示</a></p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/guibing.gif" alt="3.gif"></p><p><strong>原理</strong></p><p>将一个无序数组一分为二成两个数组，将两个无序数组变为有序数组后，再使用双指针依次选取最小的数合并为一个数组。</p><p>过程中递归调用分为若干个数组（最小为两个元素一组）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">//递归终止</span></span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一步分为子问题</span></span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//第二步递归处理子问题</span></span><br><span class="line"><span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line"><span class="built_in">merge_sort</span>(q,mid<span class="number">+1</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步合并子问题</span></span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>,i=l,j=mid<span class="number">+1</span>,tmp[r-l<span class="number">+1</span>];</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line"><span class="keyword">if</span>(q[i]&lt;=q[j]) tmp[k++]=q[i++];</span><br><span class="line"><span class="keyword">else</span> tmp[k++]=q[j++];</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid) tmp[k++]=q[i++];</span><br><span class="line"><span class="keyword">while</span>(j&lt;=r) tmp[k++]=q[j++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=l,j=<span class="number">0</span>;i&lt;=r;i++,j++) q[i]=tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><a href="https://www.acwing.com/problem/content/789/">归并排序</a></li><li><a href="https://www.acwing.com/problem/content/790/">逆序对的数量</a></li></ol><hr><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><strong>注意边界</strong></p><p>二分法有许多不同的模板，通常是因为<code>int</code>向下取整导致<code>l</code>与<code>r</code>的判定问题。</p><p>这里使用<code>下界-1</code>,<code>上界+1</code>，并且当<code>l+1==r</code>时跳出循环。</p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/erfen.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大化答案伪代码</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//......  计算y的值</span></span><br><span class="line"><span class="keyword">return</span> y&lt;=c;  <span class="comment">//x小，y大</span></span><br><span class="line"><span class="keyword">return</span> y&gt;=c;  <span class="comment">//x小，y大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l=下界<span class="number">-1</span>,r=上界<span class="number">+1</span>;</span><br><span class="line"><span class="keyword">while</span>(l<span class="number">+1</span>&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; <span class="comment">//整数二分</span></span><br><span class="line">        <span class="comment">//int mid=(l+r)/2; 实数二分</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l=mid;</span><br><span class="line"><span class="keyword">else</span> r=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小化答案伪代码</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//......  计算y的值</span></span><br><span class="line"><span class="keyword">return</span> y&gt;=c;  <span class="comment">//x大，y小</span></span><br><span class="line"><span class="keyword">return</span> y&lt;=c;  <span class="comment">//x大，y小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l=下界<span class="number">-1</span>,r=上界<span class="number">+1</span>;</span><br><span class="line"><span class="keyword">while</span>(l<span class="number">+1</span>&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>; <span class="comment">//整数二分</span></span><br><span class="line">        <span class="comment">//int mid=(l+r)/2; 实数二分</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><a href="https://www.acwing.com/problem/content/791/">数的范围</a></p></li><li><p><a href="https://www.acwing.com/problem/content/792/">数的三次方根</a></p></li></ol><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p><strong>例题</strong></p><p>输入一个长度为 $n$ 的整数序列。</p><p>接下来再输入 $m$ 个询问，每个询问输入一对 $l,r$。</p><p>对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。</p><p><strong>朴素算法</strong>：暴力遍历求解,时间复杂度为$O(m*n)$。</p><p><strong>前缀和</strong>：定义一个<code>sum[]</code>数组，<code>sum[i]</code>为前<code>i</code>个数之和，每次只需求<code>sum[r]-sum[l-1]</code>,将时间复杂度由 $O(m*n)$降为$O(m+n)$。</p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/2eadf7531e415ea2b6b4cabd2f19fe6e.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i - <span class="number">1</span>] + a[i];<span class="comment">//前缀和处理操作</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;sum[r] - sum[l - <span class="number">1</span>];<span class="comment">//查询操作</span></span><br></pre></td></tr></table></figure><hr><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p><strong>例题</strong></p><p>输入一个<code>n</code>行<code>m</code>列的整数矩阵，再输入<code>q</code>个询问，每个询问包含四个整数<code>x1</code>, <code>y1</code>, <code>x2</code>, <code>y2</code>，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。</p><p><strong>思路</strong></p><p><strong>预处理</strong>同一维前缀和一样，我们先来定义一个二维数组<code>s[][]</code>, <code>s[i][j]</code>表示二维数组中，左上角<code>(1, 1)</code>到右下角<code>(i, j)</code>所包围的矩阵元素的和。接下来推导二维前缀和的公式。</p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/0fc5ed8e9a42ee1d0120690bf1400aab.png" alt="img" style="zoom: 33%;"></p><p><strong>紫色面积</strong>是指<code>(1, 1)</code>左上角到<code>(i, j - 1)</code>右下角的矩形面积, <strong>绿色面积</strong>是指<code>(1, 1)</code>左上角到<code>(i - 1, j )</code>右下角的矩形面积。<strong>每一个颜色的矩形面积都代表了它所包围元素的和。</strong></p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/8b538feb08981caf3a525fc3fda14273.png" alt="在这里插入图片描述"></p><p><strong>预处理公式$O(mn)$</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span> ] + a[i] [j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>查询</strong></p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/858bc708d9f0256e3b41e877a6f7f6ee.png" alt="img" style="zoom:33%;"></p><p><strong>紫色面积</strong>是指 <code>(1, 1)</code>左上角到<code>(x1 - 1, y2)</code>右下角的矩形面积 ，<strong>黄色面积</strong>是指<code>(1, 1)</code>左上角到<code>(x2, y1 - 1)</code>右下角的矩形面积；</p><p><strong>不难推出：</strong></p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/43028b283e44762ecc4c6304416d3497.png" alt="在这里插入图片描述"></p><p><strong>查询公式$O(1)$</strong></p><p><code>(x1, y1)</code>为左上角，<code>(x2, y2)</code>为右下角的子矩阵的和为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[x2, y2] - s[x1 - <span class="number">1</span>, y2] - s[x2, y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><hr><ol><li><a href="https://www.acwing.com/problem/content/797/">前缀和</a></li><li><a href="https://www.acwing.com/problem/content/798/">子矩阵的和</a></li></ol><hr><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>差分可以看成前缀和的逆运算。</p><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/bfb0780877815e29fd0943cb2974d30b.png" alt="img" style="zoom: 67%;"></p><p><code>O(n)</code>预处理，查找<code>O(1)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        b[i] = a[i] - a[i - <span class="number">1</span>];      <span class="comment">//构建差分数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l, r, c;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        b[l] += c;            <span class="comment">//表示将序列中[l, r]之间的每个数加上c</span></span><br><span class="line">        b[r + <span class="number">1</span>] -= c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        b[i] += b[i - <span class="number">1</span>];      <span class="comment">//求前缀和运算</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><p><code>a[][]</code>数组是<code>b[][]</code>数组的前缀和数组，那么<code>b[][]</code>是<code>a[][]</code>的差分数组。</p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/df1ea9b38f8b698cf9663fb30c1bf7f1.png" alt="img" style="zoom:33%;"></p><p>每次在<code>[x1,y1]</code>和<code>[x2,y2]</code>间插入值<code>c</code>，使该区间每个元素的值加<code>c</code></p><p><img src="/2024/07/24/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/b5c6a0a0dbc98d0e46c376ac85e196ba.png" alt="在这里插入图片描述"></p><p><strong>完整代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);      <span class="comment">//构建差分数组</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (q--)&#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">//二维前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>使用双指针是降低算法复杂度的一个有效途径，有些问题的暴力解法时间复杂度是$O(n^2)$，但使用双指针可以大幅度降低算法复杂度。如果面试者能将求解过程从暴力法优化到双指针，说明面试者的基础知识、代码能力、逻辑思维都是十分扎实的。</p><p>同贪心算法一样，双指针的难点在于自己想不出、别人的理解不了、正确性难以证明。双指针算法没有固定的模板,而是一种解决问题思维方式。</p><p>常用的双指针法有一下几类：</p><ol><li><p>左右指针：两个指针，相向而走，中间相遇。</p></li><li><p>快慢指针：两个指针，有快有慢，同向而行。</p></li><li><p>灵活运用：两个指针，灵活运用，伺机而动。</p></li></ol><p><strong>例题</strong></p><p>给定一个长度为 $n$ 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> a[MAXN], first[MAXN] = &#123;<span class="number">0</span>&#125;, last[MAXN] = &#123;<span class="number">0</span>&#125;, ans = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用first和last数组记录每个数字的第一次和最后一次出现的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 如果这个数字之前出现过，更新j为这个数字第一次出现的位置的下一个位置</span></span><br><span class="line">        <span class="keyword">if</span> (last[a[i]] != <span class="number">0</span>) j = <span class="built_in">max</span>(j, first[a[i]] + <span class="number">1</span>);</span><br><span class="line">        last[a[i]] = i;  <span class="comment">// 更新这个数字的最后一次出现的位置</span></span><br><span class="line">        <span class="keyword">if</span> (first[a[i]] == <span class="number">0</span>) first[a[i]] = i;  <span class="comment">// 如果这是第一次出现这个数字，更新第一次出现的位置</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, i - j + <span class="number">1</span>);  <span class="comment">// 更新最长区间的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码还可以优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, r = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; ++ i)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        ++ s[a[i]];</span><br><span class="line">        <span class="keyword">while</span> (s[a[i]] &gt; <span class="number">1</span>) -- s[a[j++]]; <span class="comment">// 先减次数后右移</span></span><br><span class="line">        r = <span class="built_in">max</span>(r, i - j + <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><a href="https://www.acwing.com/problem/content/801/">最长连续不重复子序列</a></li><li><a href="https://www.acwing.com/problem/content/802/">数组元素的目标和</a></li><li><a href="https://www.acwing.com/problem/content/2818/">判断子序列</a></li></ol><hr><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p><strong>lowbit</strong>  $O(nlogn)$<br>使用lowbit操作，进行，每次lowbit操作截取一个数字最后一个1后面的所有位，每次减去lowbit得到的数字，直到数字减到0，就得到了最终1的个数，</p><p><strong>lowbit原理</strong><br>根据计算机负数表示的特点，如一个数字原码是<code>10001000</code>，他的负数表示形势是补码，就是反码+1，反码是<code>01110111</code>，加一则是<code>01111000</code>，二者按位与得到了<code>1000</code>，就是我们想要的lowbit操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x, s = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) s++;</span><br><span class="line">        cout&lt;&lt; s &lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p><strong>暴力枚举</strong> $O(nlogn)$</p><p><strong>思路</strong><br>对于每个数字a，a&amp;1得到了该数字的最后一位，之后将a右移一位，直到位0，就得到了1的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a)&#123;</span><br><span class="line">            k+=a&amp;<span class="number">1</span>;</span><br><span class="line">            a=a&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法3"><a href="#方法3" class="headerlink" title="方法3"></a>方法3</h2><p><strong>系统自带函数</strong> $O(loglogx)$ (好像是这样？反正比手写快🤣)</p><p>只要写了 main 函数，就可以使用。OI 中可用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; __builtin_popcount(x) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure><p>返回 𝑥 在二进制下 $1$ 的个数。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
