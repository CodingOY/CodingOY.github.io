---
title: 算法笔记

---

# 基础算法

## 快速排序

![2.gif](https://cdn.acwing.com/media/article/image/2019/05/19/1130_1196bbb27a-2.gif)

**原理**

选定某个划分值x（一般选取数组首个元素），将待排数组分为左右两部分。左边均为大于x，右边均为小于x。再递归调用函数处理左右两边。

快排属于**分治算法**，分治算法都有三步：

1. 分成子问题
2. 递归处理子问题
3. 子问题合并

```cpp
void quick_sort(int q[],int l,int r){
    //递归终止
	if(l>=r) return;
	
	int x=q[l+r>>1],i=l-1,j=r+1;
	while(i<j){
		do i++;while(q[i]<x);
		do j--;while(q[j]>x);
		if(i<j) swap(q[i],q[j]);
	}
	
	quick_sort(q,l,j);
	quick_sort(q,j+1,r);
}
```

**STL**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1000000+100;
int a[N],n,m,i,j;

int main(){//sort函数即为快排
    ios::sync_with_stdio(false);
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++)
        cout<<a[i]<<" ";
    cout<<endl;
}
```

练习

1. [快速排序](https://www.acwing.com/problem/content/787/)
2. [第k个数](https://www.acwing.com/problem/content/788/) 



---

## 归并排序

[视频演示](https://www.bilibili.com/video/BV1Na411e7Vg/?spm_id_from=333.337.search-card.all.click&vd_source=4cf1335c21865cdae9c04c4d1146427a)

![3.gif](https://cdn.acwing.com/media/article/image/2019/05/19/1130_4cf170747a-3.gif)

**原理**

将一个无序数组一分为二成两个数组，将两个无序数组变为有序数组后，再使用双指针依次选取最小的数合并为一个数组。

过程中递归调用分为若干个数组（最小为两个元素一组）。

```cpp
void merge_sort(int q[],int l,int r){
    //递归终止
	if(l>=r) return;
	
    //第一步分为子问题
	int mid=l+r>>1;
    //第二步递归处理子问题
	merge_sort(q,l,mid);
	merge_sort(q,mid+1,r);
	
    //第三步合并子问题
	int k=0,i=l,j=mid+1,tmp[r-l+1];
	while(i<=mid&&j<=r)
		if(q[i]<=q[j]) tmp[k++]=q[i++];
		else tmp[k++]=q[j++];
	while(i<=mid) tmp[k++]=q[i++];
	while(j<=r) tmp[k++]=q[j++];
	
	for(i=l,j=0;i<=r;i++,j++) q[i]=tmp[j];
}

```

[归并排序](https://www.acwing.com/problem/content/789/)

[逆序对的数量](https://www.acwing.com/problem/content/790/)



---

## 二分查找

**注意边界**

![微信截图_20240327213556](C:\Users\ohyoung\Desktop\微信截图_20240327213556.png)

[数的范围](https://www.acwing.com/problem/content/791/)

[数的三次方根](https://www.acwing.com/problem/content/792/)

---

## 前缀和

### 一维前缀和

**例题**

输入一个长度为 $n$ 的整数序列。

接下来再输入 $m$ 个询问，每个询问输入一对 $l,r$。

对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。

**朴素算法**：暴力遍历求解,时间复杂度为$O(m*n)$。

**前缀和**：定义一个`sum[]`数组，`sum[i]`为前`i`个数之和，每次只需求`sum[r]-sum[l-1]`,将时间复杂度由 $O(m*n)$降为$O(m+n)$。

```cpp
for(int i=1;i<=n;i++) q[i]+=q[i-1];//前缀和处理操作

cout<<q[r]-q[l-1];//查询操作
```

---

### 二维前缀和

**例题**

输入一个`n`行`m`列的整数矩阵，再输入`q`个询问，每个询问包含四个整数`x1`, `y1`, `x2`, `y2`，表示一个子矩阵的左上角坐标和右下角坐标。对于每个询问输出子矩阵中所有数的和。

**思路**同一维前缀和一样，我们先来定义一个二维数组`s[][] `, `s[i][j] `表示二维数组中，左上角`(1, 1)`到右下角`(i, j)`所包围的矩阵元素的和。接下来推导二维前缀和的公式。



